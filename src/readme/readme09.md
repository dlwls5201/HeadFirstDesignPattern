# 이터레이터와 컴포지트 패턴

>객체를 저장하는 방식(배열, 스텍, 해시테이블 등)은 보여주지 않으면서도 클라이언트로 하여금 객체들에게 일일이 접근할 수 있게 해줄 수 있는 방법이 있습니다.
그리고 한 방에 멋진 자료 구조로 변신할 수 있는, 객체들로 구성된 수퍼 컬렉션에 대해서도 알아보겠습니다.

## 이터레이터 패턴

이터레이터 패턴은 컬렉션 구현 방법을 노출시키지 않으면서도 그 집할체 안에 들어있는 모든 항목에 접근할 수 있게 해주는 방법을 제공해 줍니다.

이 패턴을 이용하면 집합체 내에서 어떤 식으로 일이 처리되는지에 대해서 전혀 모르는 상태에서 그 안에 들어있는 모든 항목들에 대해서 반복작업을 수행할 수 있습니다.
즉 내부적인 구현 방법을 외부로 노출시키지 않으면서도 집할체에 있는 모든 항목에 일일이 접근할 수 있습니다.

## 디자인 원칙

클래스를 바꾸는 이유는 한 가지 뿐이어야 한다.

**응집도**

응집도란 한 클래스 또는 모듈이 특정 목적 또는 역활을 얼마나 일관되게 지원하는지를 나타내는 척도라고 할 수 있습니다.

어떤 모듈 또는 클래스의 응집도가 높다는 것은 일련의 서로 연관된 기능이 묶여있다는 것을, 응집도가 낮다는 것은 서로 상관 없는 기능들이 묶여있다는 것을 뜻합니다.
이 원칙을 잘 따르는 클래스는 두 개 이상의 역활을 맡고 있는 클래스에 비해 응집도가 높고, 관리하기도 더 용이한 편입니다.


## 컴포지트 패턴

컴포지트 패턴을 이용하면 객체들을 트리 구조로 구성하여 부분과 전체를 나타내는 계층구도로 만들 수 있습니다. 이 패턴을 이용하면 클라이언트에서 개별 객체와
다른 객체들로 구성된 복합 객체(composite)를 똑같은 방법으로 다룰 수 있습니다.

## 누가 무엇을 할까요?

- 스테이트 패턴 : 어떤 상태가 바뀜에 따라 객체의 행동을 바꿀 수 있습니다.
- 어댑터 패턴 : 하나 이상의 클래스의 인터페이스를 반환합니다.
- 이터레이터 패턴 : 컬렉션의 구분을 드러내지 않으면서도 컬렉션에 있는 모든 객체들에 대해 반복작업을 할 수 있습니다.
- 퍼사드 패턴 : 일련의 클래스들에 대한 인터페이스를 단순화 시킵니다.
- 컴포지트 패턴 : 클라이언트에서 객체 컬렉션과 개별 객체를 똑같은 식으로 처리할 수 있습니다.
- 옵저버 패턴 : 어떤 상태가 변경되었을 때 일련의 객체들한테 연락을 할 수 있습니다.





