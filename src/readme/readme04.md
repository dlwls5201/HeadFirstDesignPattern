# 팩토리 패턴

>느슨한 결합을 이용하는 객체지향 디자인을 만들어 봅시다.<br>
>객체의 인스턴스를 만드는 작업이 항상 공개되어 있어야 하는 것은 아니며, 모든 것을 공개했다가는 결합과 관련된 문제가 생길 수 있다는 것을 배우게 됩니다.

**New는구상객체를뜻합니다**
new를 사용하는 것은 구상 클래스의 인스턴스를 만드는 것입니다. 당연히 인터페이스가 아닌 특정 구현을 사용하는 거죠. 구상 클래스를 바탕으로 코딩을 하면
나중에 코드를 수정해야 할 가능성이 높아지고, 유연성이 떨어지게 됩니다.

## 간단한 팩토리

객체 생성을 처리하는 클래스를 팩토리라고 부릅니다. 간단한 팩토리는 디자인 패턴이라고는 할 수 없습니다. 프로그래밍을 하는데 있어서
자주 쓰이는 관용구에 가깝다고 할 수 있습니다.

## 팩토리 메소드 패턴 정의

팩토리 메소드 패턴에서는 객체를 생성하기 위한 인터페이스를 정의하는데, 어떤 클래스의 인스턴스를 만들지는 서브클래스에서 결정하게 만듭니다.
패곹리 메소드 패턴을 이용하면 클래스의 인스턴스를 만드는 일을 서브클래스에게 맡기는 것이죠.

-> 팩토리 메소드 패턴에서는 어떤 클래스의 인스턴스를 만들지를 서브클래스에서 결정한다

- 팩토리 메소드 패턴에서는 객체를 생성하기 위해 인터페이스를 정의하는데, 어떤 클래스의 인스턴스를 만들지는 서브클래스에서 결정하게 만듭니다.
- 팩토리 메소드 패턴을 이용하면 클래스의 인스턴스를 만드는 일을 서브 클래스에게 맡기게 되는 것이죠.
- 팩토리 메소드 패턴을 사용하여 구상 형식의 인스턴스를 만드는 작업을 캡슐화 할 수 있습니다.

**간단한팩토리와팩토리메소드차이**

간단한 팩토리는 일회용 처방에 불과한 반면, 팩토리 메소드 패턴을 이용하면 어떤 구현을 사용할지를 서브클래스에서 결정하는 프레임워크를 만들 수 있다는 결정적인 차이점이 있습니다.


## 추상 팩토리 패턴 정의

추상 팩토리 패턴에서는 인터페이스를 이용하여 서로 연관된, 또는 의존하는 객체를 구상 클래스를 지정하지 않고도 생성할 수 있습니다.

- 추상 팩토리 패턴을 사용하면 클라이언트에서 추상 인터페이스를 통해서 일련의 제품들을 공급받을 수 있습니다.


## 팩토리 메소드 패턴과 추상 팩토리 패턴의 차이

팩토리 메소드 패턴

- 서브클래스를 통해서 객체를 만듭니다. 그렇게 하면 클라이언트에서는 자신이 사용할 추상 형식만 알면 됩니다.
- 구상 형식은 서브클래스에서 처리해줍니다. 클라이언트와 구상 형식을 분리시켜주는 역활을 합니다.

클라이언트 코드와 인스턴스를 만들어야 할 구상 클래스를 분리시켜야 할 때 사용.
팩토리 메소드 패턴을 쓸 때는 제 서브클래스를 만들고 팩토리 메소드를 구현하기만 하면 됩니다.

```kotlin
    abstract class PizzaStore {

        fun orderPizza(type: String): Pizza? {

            val pizza = createPizza(type)

            pizza?.run {
                prepare()
                bake()
                cut()
                box()
            }

            return pizza
        }

        /**
         *  팩토리 메소드 선언
         *
         *  구상 클래스의 인스턴스를 만드는 일을 한 객체에서 전부 처리하는 방식에서 일련의 서브클래스에서 처리하는 방식으로 넘어오게 되었습니다.
         *  Pizza 인스턴스를 만드는 일은 이제 팩토리 역활을 하는 메소드에서 맡아서 처리합니다.
         *
         *  팩토리 메소드는 객체 생성을 처리하며, 팫토리 메소드를 이용하면 객체를 생성하는 작업을 서브클래스에 캡슐화시킬 수 있습니다.
         */
        abstract fun createPizza(type: String): Pizza?

    }
```

추상 팩토리 패턴

- 제품을 만들기 위한 추상 형식을 제공합니다. 제품이 생산되는 방법은 이 형식의 서브클래스에서 정의됩니다.
- 구상 팩토리를 구현할 떄는 팩토리 메소드 패턴을 사용하기도 합니다.

클라이언트에서 서로 연관된 일련의 제품들을 만들어야 할 때, 즉 제품군을 만들어야 할 때 사용

```kotlin
 class NYPizzaFactory : PizzaStore() {

        /**
         * 추상 팩토리 패턴에서는 인터페이스를 이용하여 서로 연관된, 또는 의존하는 객체를 구상 클래스를 지정하지 않고도 생성할 수 있습니다.
         */
        override fun createPizza(type: String):Pizza? {

            var pizza: Pizza? = null

            val nyIgredientFactory = NYPizzaIngredientFactory()

            when(type) {

                "cheese" -> {
                    pizza = CheesePizza(nyIgredientFactory)
                }
                "greek" -> {
                    //pizza = NYStyleGreekPizza()
                }
                "pepperoni" -> {
                    //pizza = NYStylePepperoniPizza()
                }
            }

            return pizza
        }
    }
```

## 정리


팩토리 메서드 - 클래스 생성

객체를 생성하기 위해 인터페이스를 정의하지만, 어떤 클래스의 인스턴스를 생성할 지에 대한 결정은 서브클래스가 내리도록 합니다.

추상 팩토리 - 객체 생성

상세화된 서브클래스를 정의하지 않고도 서로 관련성이 있거나 독립적인 여러 객체 의 군을 생성하기 위한 인터페이스를 제공합니다.


차이점

팩토리 메소드 패턴이 클래스가 객체를 생성하는 패턴이라고 하면, 추상 팩토리 패턴에서는 객체가 객체를 만드는 방법이라는 점이다.
그리고 추상팩토리에서는 상속 구조를 둠으로서 세밀한 팩토리 관리가 가능하다.



## 디자인 원칙

- 추상화된 것에 의존하도록 만들어라. 구상클래스에 의존하도록 많들지 않도록 한다.

**의존성 뒤집기 원칙(Dependency Inversion Principle)**

"특정 구현이 아닌 인터페이스에 맞춰서 프로그래밍한다" 비슷하긴 하지만 의존성 뒤집기 원칙은 추상화를 더 강조합니다.
이 원칙에서는 고수준 구성요소고 저수준 구성요소에 의존하면 안된다는 것이 내포되어 있습니다.


## 원칙을 지키기 위한 가이드 라인

- 어떤 변수에도 구상 클래스에 대한 레퍼런스를 저장하지 맙시다
- 구상 클래스에서 유도될 클래스를 만들지 맙시다.
- 베이스 클래스에 이미 구현되어 있던 메소드를 오버라이드 하지 맙시다.